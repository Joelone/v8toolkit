bidirectional Factory objects need to be wrapped so they can be used from javascript, not just have their objects
passed back from c++ helpers

Debugging support - looks like there are packages out there for integrating it with chrome for debugging



Building with gn:
fresh computer:
fetch v8

existing computer:
rm -rf v8
gclient sync (from $HOME)


No support for pointer to l/r-value ref qualified member function


Need to change debugging to use v8's built-in debugging


constructors don't support default arguments yet
 - fairly difficult to route the parameters through


ClassParser:
-------------


FEATURE: std::function default parameters are not supported - ignored with warning message
 - cast to js then back to native trick doesn't work for them because there's no casttojs for them






Need to make sure to get include files for constructor input parameter types
 - it looks like we are, but it's not showing up in the output file for GroundRegionCollection's constructor:
   -     class_wrapper.add_constructor<class Map &, class GroundRegion &&>("GroundRegionCollection", isolate);
Logs:
Went from class Map & to class Map
is not a FUNCTION TYPE
0x137572e0Got include string for class Map: "map.h"
GroundRegionCollection now has 9 include files having added "map.h"


constructors don't take default arguments and once they do, it needs to be added to class_parser

Bidirectional types without a specified bidirectional constructor aren't properly setting an error - or error isn't being
  looked at - program crashes when trying to write out the null constructor later (right after log message cc3 is printed)


BUG: ClassParser generates code for multiple constructors with the same name -- also puts an extra newline after each constructor
       instead of only after last one

TRIVIAL: ClassParser generated code - expose_static_methods indentation is off:

           class_wrapper.finalize(true);
   class_wrapper.expose_static_methods("InputEvent", isolate);



Add support for enums.  Here is sample code for how to get enums from a CXXRecordDecl:

 for(auto & childdecl : record_decl->decls()) {
        if (auto enum_decl = dyn_cast<EnumDecl>(childdecl)) {
            // prints name of enum class
            std::cerr << fmt::format("enum decl name: {}", enum_decl->getName().str()) << std::endl;
            for(auto enumerator : enum_decl->enumerators()) {
                // prints the name of each value in the enum
                std::cerr << fmt::format("Enumerator: {}", enumerator->getNameAsString(), enumerator->) << std::endl;
            }
        }
    }

